- py-code: |
   def py_func(project, data):
      data = type(project)(source=data).data
      name = data['name']
      args = ', '.join(data.get('args', ()))
      code = data['code'].replace('\n', '\n  ')
      code = (
         f"def {name}({args}):\n"
         f"  {code}"
      )
      lc_scope = {}
      exec(code, globals(), lc_scope)
      project[name] = lc_scope[name]

   def py_key(project, data):
      data = type(project)(source=data).data
      name = data['name']
      code = data['code'].replace('\n', '\n  ')
      code = (
        f"def {name}():\n"
        f"  {code}"
      )
      lc_scope = {}
      exec(code, globals(), lc_scope)
      project[name] = lc_scope[name]()

   project['handlers', 'py-key'] = py_key
   project['handlers', 'py-func'] = py_func


- py-key:
   name: rules
   code: |
      import std
      return std.RULES


- py-key:
   name: scope
   code: |
      import actl


      def _getPyToAVars():
         for varName in ('print',):
            var = eval(varName)
            yield varName, actl.objects.PyToA.call(var)


      def _getAVars():
         for varName, clsName in (
            ('True', 'ATrue'),
            ('False', 'AFalse'),
            ('Bool', 'Bool'),
            ('String', 'String'),
            ('Number', 'Number'),
            ('while', 'While'),
            ('if', 'If'),
            ('elif', 'elif_'),
            ('else', 'else_')
         ):
            var = getattr(actl.objects, clsName)
            yield varName, var


      return actl.Scope({
         **dict(_getPyToAVars()),
         **dict(_getAVars())
      })


- py-func:
   name: parse
   code: |
      import actl

      return actl.Parser(this['scope'], this['rules'], this['uinput'])


- py-func:
   name: execute
   code: |
      import std

      std.Executor(this['code'], this['scope'])


- py-func:
   name: build
   code: |
      from actl import Buffer

      parser = this['parse']()
      code = Buffer(parser).watch(print)
      this['code'] = code
      this['execute']()
