- py-code: |
   def py_func(project, data):
      data = type(project)(source=data).data
      name = data['name']
      args = ', '.join(data.get('args', ()))
      code = data['code'].replace('\n', '\n  ')
      code = (
         f"def {name}({args}):\n"
         f"  {code}"
      )
      lc_scope = {}
      exec(code, globals(), lc_scope)
      project[name] = lc_scope[name]

   def py_key(project, data):
      data = type(project)(source=data).data
      name = data['name']
      code = data['code'].replace('\n', '\n  ')
      code = (
        f"def {name}():\n"
        f"  {code}"
      )
      lc_scope = {}
      exec(code, globals(), lc_scope)
      project[name] = lc_scope[name]()
   project['handlers', 'py-key'] = py_key
   project['handlers', 'py-func'] = py_func


- py-func:
   name: build
   code: |
      import actl
      import std

      scope = this['scope']
      parser = actl.Parser(scope, this['rules'], this['uinput'])
      code = list(parser)
      print(code)
      std.Executor(code, scope)


- py-key:
   name: rules
   code: |
      import std
      return std.RULES


- py-key:
   name: scope
   code: |
      import actl


      def _getPyToAVars():
         for varName in ('True', 'False', 'print'):
            var = eval(varName)
            yield varName, actl.objects.PyToA.fromPy(var)


      def _getAVars():
         for varName, clsName in (
            ('String', 'String'),
            ('Number', 'Number'),
            ('while', 'While')
         ):
            var = getattr(actl.objects, clsName)
            yield varName, var


      return actl.Scope({
         **dict(_getPyToAVars()),
         **dict(_getAVars())
      })
