tokenizer:
  pfunction:
    function: "__import__('actl').tokenizer.Tokenizer"
    kwargs:
      buff:
        pget: "this['buff',]"


scope:
  def pfunction: |
    actl = __import__('actl')
    std = __import__('std')
    scope = std.Scope()
    scope.update({"stack":[], "codes":[], actl.tokens.VARIABLE("print"):'print'})
    scope.update(__import__('std.abuiltins').abuiltins.abuiltins)
    return scope


rules:
  pget: "__import__('std').RULES"


parser:
  pfunction:
    function: "__import__('actl').code.Parser"
    kwargs:
      buff:
        pget: "this['tokenizer',].tokenize()"
      rules:
        pget: "this['rules',]"


sexecutor:
  pfunction:
    function: "__import__('std').SExecutor"
    kwargs:
      code:
        pget: "this['code',]"


translator:
  pfunction:
    function: "__import__('adb').TranslateToString"
    kwargs:
      code:
        pget: "this['code',]"


build:
  def pfunction: |
    this['scope',] = this['scope',]()

    Code = __import__('actl').code.Code

    this['code',] = Code(buff=list(this['parser',].parse()), scope=this['scope',])

    LinkerLayer = __import__('actl').project.LinkerLayer
    llayer = LinkerLayer(this['translator',])
    llayer.link()


mainf:
  pfset: "lambda path: this.__setitem__(('buff',), open(path).read())"
